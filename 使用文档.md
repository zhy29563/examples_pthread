# 1. 线程的基础知识

- 线程操作包含线程创建(`creation`), 结束(`termination`), 同步(`join`, `detach`), 调度(`scheduling`), 数据管理(`data management`)和处理交互(`process interaction`)。
- 线程不维护已创建的线程列表，也不知道创建它的线程
- 一个进程中的所有线程共享相同的地址空间
- 统一进程中的线程共享
  - 处理器指令
  - 多数数据
  - 文件描述符
  - 信号与信号处理函数
  - 当前的工作目录
  - 用户ID与组ID
- 线程特有的数据
  - 线程ID
  - 寄存器，栈指针
  - 局部变量堆栈，函数的返回地址 
  - 信号掩码
  - 优先级
  - `errno`变量的返回值
- `pthread`函数执行正确返回 `0`



# 2. 基本使用

## 2.0 CMAKE文件

```cmake
cmake_minimum_required(VERSION 3.0.0)
project(pthread_examples VERSION 0.1.0 LANGUAGES C)

IF (CMAKE_BUILD_TYPE AND (CMAKE_BUILD_TYPE STREQUAL Debug))
    ADD_COMPILE_DEFINITIONS(DEBUG)
ENDIF()

# FindThreads Module
# 该模块用于确定系统的线程库。
# 如果查找到线程库，该模块定义目标：Threads::Threads
# 定义以下变量：
#   Threads_FOUND
#       如果有支持的线程库被查找到
#   CMAKE_THREAD_LIBS_INIT
#       将要使用的线程库。如果该线程库是由系统库提供的，并且不需要特殊标志来使用它们，则可能为空
#   CMAKE_USE_WIN32_THREADS_INIT
#       如果查找到的库是WIN32，则返回1，否则返回0
#   CMAKE_USE_PTHREADS_INIT
#       指示找到的库是否为pthread兼容库
#   CMAKE_HP_PTHREADS_INIT
#       指示找到的库是否是HP线程库
SET(THREADS_PREFER_PTHREAD_FLAG ON)
find_package(Threads REQUIRED)
IF (Threads_FOUND)
    message(STATUS ======================================================)
    message(STATUS "CMAKE_THREAD_LIBS_INIT       : ${CMAKE_THREAD_LIBS_INIT}")
    message(STATUS "CMAKE_USE_WIN32_THREADS_INIT : ${CMAKE_USE_WIN32_THREADS_INIT}")
    message(STATUS "CMAKE_USE_PTHREADS_INIT      : ${CMAKE_USE_PTHREADS_INIT}")
    message(STATUS "CMAKE_HP_PTHREADS_INIT       : ${CMAKE_HP_PTHREADS_INIT}")
    message(STATUS ======================================================)
    add_definitions     ( ${EIGEN3_DEFINITIONS} )
    include_directories ( ${EIGEN3_INCLUDE_DIRS} )
ENDIF()

# 链接线程库
link_libraries(Threads::Threads)

# 创建线程
add_executable(pthread_create main.c)
```

## 2.1 线程属性

### 2.1.1 线程属性结构

```c++
#  define __SIZEOF_PTHREAD_ATTR_T 56

union pthread_attr_t
{
  char __size[__SIZEOF_PTHREAD_ATTR_T];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;
```

### 2.1.2 初始化线程属性

```c++
int pthread_attr_init(pthread_attr_t *attr);
```

- 以默认值的方式初始化线程属性对象。
- 经过初始化后的线程属性对象可以使用不同的函数（`pthread_attr_set*`）设置对应的属性，最后将该属性用于`pthread_create`函数，用于创建具有指定属性的线程。
- 调用该函数初始化一个`已初始化的`的线程属性对象，将导致不确定的行为。

### 2.1.3 销毁线程属性

```c++
int pthread_attr_destroy(pthread_attr_t *attr);
```

- 销毁一个线程属性对象
- 线程属性对象销毁后，不影响使用该属性创建的线程对象
- `已销毁的`线程属性对象，可以使用`pthread_attr_init`重新初始化
- 使用一个`已销毁的`线程属性对象，将导致不确定的行为

### 2.1.4 线程属性之分离状态

```c++
int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);
```

- 获取或设置线程属性对象中的线程分离状态。

- 有两种状态值：

  - `PTHREAD_CREATE_DETACHED`

    使用该属性创建的线程，处于分离态


  - `PTHREAD_CREATE_JOINABLE`

    使用该属性创建的线程，处于关联态。默认值。


- 拥有`PTHREAD_CREATE_JOINABLE`属性的线程，可通过`pthread_detach`修改为`PTHREAD_CREATE_DETACHED`。反之不可行。

### 2.1.5 线程属性之栈保护区尺寸

```c++
int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);
int pthread_attr_getguardsize(const pthread_attr_t *attr, size_t *guardsize);
```

- 如果该属性值大于零，则使用该属性创建的线程，在线程栈末尾多出一块至少`guard size`字节的保护区。
- 如果该属性值等于零，则无线程栈保护区。
- 默认保护大小与系统页面大小相同。
- 如果使用`pthread_attr_setstack`或`pthread_attr_setstackaddr`设置了线程属性对象的栈地址，则栈保护区大小被忽略。

### 2.1.6 线程属性之调度继承

```c++
int pthread_attr_setinheritsched(pthread_attr_t *attr, int inheritsched);
int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *inheritsched);
```

- 获取或设置线程线程对象中的继承线程调度属性。该属性指示使用该线程对象创建的线程是继承`父线程`的调度属性，还是线程属性对象中指定的调度属性。以下线程调度属性受该属性的影响：

  - 调度策略（`pthread_attr_setschedpolicy`）

  - 调度优先级（`pthread_attr_setschedparam`）

  - 调度作用域（`pthread_attr_setscope`）


- 继承调度属性支持以下值：

  - `PTHREAD_INHERIT_SCHED`

    继承`父线程`的调度属性。线程属性对象中的调度属性被忽略。默认值。


  - `PTHREAD_EXPLICIT_SCHED`

    使用该线程属性对象中的调度属性

### 2.1.7 线程属性之调度策略

```c++
int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy);
int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy);
```

- 调度器是一个内核组件，该组件决定哪一个可运行的线程将运行。每一个线程都有一个相关的调度策略，一个静态的调度优先级。调度器根据系统上所有线程的调度策略和调度优先级做出调度决定。

- 对于正常调度策略（`SCHED_OTHER, SCHED_IDLE, SCHED_BATCH`），调度优先级不用于调度决定，必须设置为`0`。

- 对于实时调度策略（`SCHED_FIFO, SCHED_RR`）,调度优先级的范围`[1, 99]`，值越大，优先级越高。
- 对于特殊的调度策略，可以使用`sched_get_priority_min(2)`与`sched_get_priority_max(2)`获取调度优先级的上下限

- 该属性支持以下值：

  - `SCHED_FIFO`

    先入先出调度策略。该值仅能用于线程调度优先级高于零的线程。这意味着，一旦具有`SCHED_FIFO`属性的线程处于可运行状态，它总是立即抢占正在运行的具有正常调度策略的线程。
  
  
    - `SCHED_RR`
  
      循环调度策略。该策略是`SCHED_FIFO`策略的加强版。
  
  
    - `SCHED_OTHER`
  
      默认调度策略。此时线程调度优先级必须为`0`。
  

### 2.1.8 线程属性之调度参数

```c++
int pthread_attr_setschedparam(pthread_attr_t *attr,  const struct sched_param *param);
int pthread_attr_getschedparam(const pthread_attr_t *attr, struct sched_param *param);

struct sched_param {
    int sched_priority;     /* Scheduling priority */
};
```

### 2.1.9 线程属性之调度作用域

```c++
int pthread_attr_setscope(pthread_attr_t *attr, int scope);
int pthread_attr_getscope(const pthread_attr_t *attr, int *scope);
```

- `PTHREAD_SCOPE_SYSTEM`

  使用具有该属性的线程属性对象创建的线程将在`系统`级别上竞争资源。

- `PTHREAD_SCOPE_PROCESS`

  使用具有该属性的线程属性对象创建的线程将在`进程`级别上竞争资源。

### 2.1.10 线程属性之线程栈

```c++
// 栈地址与栈尺寸
int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize);
int pthread_attr_getstack(const pthread_attr_t *attr, void **stackaddr, size_t *stacksize);

// 栈地址
int pthread_attr_setstackaddr(pthread_attr_t *attr, void *stackaddr);
int pthread_attr_getstackaddr(const pthread_attr_t *attr, void **stackaddr);

// 栈尺寸
int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *stacksize);
```

### 2.1.11 案例：获取线程属性默认值

- 源码

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <pthread.h>
  
  int main(int argc, char const *argv[])
  {
      pthread_attr_t attr;
      pthread_attr_init(&attr);
  
      {
          int detech_state = 0;
          pthread_attr_getdetachstate(&attr, &detech_state);
          printf("default: detech state   = %s\n",
                 detech_state == PTHREAD_CREATE_DETACHED ? "PTHREAD_CREATE_DETACHED" :
                 detech_state == PTHREAD_CREATE_JOINABLE ? "PTHREAD_CREATE_JOINABLE" : "???");
      }
  
      {
          size_t guard_size = 0;
          pthread_attr_getguardsize(&attr, &guard_size);
          printf("default: guard size     = %lu\n", guard_size);
      }
  
      {
          int inherit_sched = 0;
          pthread_attr_getinheritsched(&attr, &inherit_sched);
          printf("default: inherit sched  = %s\n",
                 inherit_sched == PTHREAD_INHERIT_SCHED ? "PTHREAD_INHERIT_SCHED" :
                 inherit_sched == PTHREAD_INHERIT_SCHED ? "PTHREAD_INHERIT_SCHED" : "???");
      }
  
      {
          struct sched_param param;
          pthread_attr_getschedparam(&attr, &param);
          printf("default: sched_param    = %d\n", param.sched_priority);
      }
  
      {
          int sched_policy = 0;
          pthread_attr_getschedpolicy(&attr, &sched_policy);
          printf("default: sched policy   = %s\n",
                 sched_policy == SCHED_FIFO ? "SCHED_FIFO" :
                 sched_policy == SCHED_RR  ? "SCHED_RR" :
                 sched_policy == SCHED_OTHER ? "SCHED_OTHER" : "???");
      }
  
      {
          int scope = 0;
          pthread_attr_getscope(&attr, &scope);
          printf("default: scope          = %s\n",
                 scope == PTHREAD_SCOPE_SYSTEM ? "PTHREAD_SCOPE_SYSTEM" :
                 scope == PTHREAD_SCOPE_PROCESS ? "PTHREAD_SCOPE_PROCESS" : "???");
      }
  
      {
          void *stack_addr = NULL;
          size_t stack_size = 0;
          pthread_attr_getstack(&attr, &stack_addr, &stack_size);
          printf("default: stack_addr     = %p\n", stack_addr);
          printf("default: stack_size     = %lu\n", stack_size);
      }
  
      {
          void *stack_addr = NULL;
          pthread_attr_getstackaddr(&attr, &stack_addr); // 已弃用
          printf("default: stack_addr     = %p\n", stack_addr);
      }
  
      {
          size_t stack_size = 0;
          pthread_attr_getstacksize(&attr, &stack_size);
          printf("default: stack_size     = %lu\n", stack_size);
      }
      pthread_attr_destroy(&attr);
      exit(EXIT_SUCCESS);
  }
  ```

- 输出

  > default: detech state   = PTHREAD_CREATE_JOINABLE
  > default: guard size     = 4096
  > default: inherit sched  = PTHREAD_INHERIT_SCHED
  > default: sched_param    = 0
  > default: sched policy   = SCHED_OTHER
  > default: scope          = PTHREAD_SCOPE_SYSTEM
  > default: stack_addr     = (nil)
  > default: stack_size     = 0
  > default: stack_addr     = (nil)
  > default: stack_size     = 8388608

## 2.2 线程创建

### 2.2.1 API

```cpp
int pthread_create(pthread_t *thread,
                   const pthread_attr_t *attr,
                   void *(*start_routine) (void *),
                   void *arg);
```

- 参数

  - `thread` 

    线程的唯一标识。在线程内部使用`pthread_self()`获取。

  - `attr`

    线程属性。设置为`NULL`表示使用默认属性。

  - `start_routime`

    线程工作函数。类型为以`void *`为参数，并返回`void *`

  - `arg`

    传递给线程工作函数（`start_routime`）的数据指针。设置为`NULL`标识无需传递数据。

### 2.2.2 案例：默认值创建线程

- 源码

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <pthread.h>
  
  void *start_routine(void *ptr)
  {
      printf("子线程(%lu)等待3秒后退出...\n", pthread_self());
      sleep(3);
      printf("子线程(%lu)即将退出...\n", pthread_self());
      return (void *)NULL;
  }
  
  int main(int argc, char const *argv[])
  {
      printf("主线程(%lu)开始运行...\n", pthread_self());
      pthread_t thread_id;
  
      {
          // 以默认线程属性，创建无数据传递的线程
          pthread_attr_t attr;
          pthread_attr_init(&attr);
          pthread_create(&thread_id, &attr, start_routine, NULL);
          pthread_attr_destroy(&attr);
  
          // 下面这条语句与上面的四条语句等价
          // pthread_create(&thread_id, NULL, start_routine, NULL);
      }
  
      printf("主线程(%lu)等待5秒后结束...\n", pthread_self());
      sleep(5);
  
      printf("主线程(%lu)即将退出...\n", pthread_self());
      exit(EXIT_SUCCESS);
  }
  ```

  

- 输出

  > 主线程(139943698245440)开始运行...
  > 主线程(139943698245440)等待5秒后结束...
  > 子线程(139943698241280)等待3秒后退出...
  > 子线程(139943698241280)即将退出...
  > 主线程(139943698245440)即将退出...

### 2.2.3 案例：线程传参

- 源码

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <pthread.h>
  #include <string.h>
  
  typedef struct _student
  {
      int id;
      int age;
      char name[32];
  } student;
  
  void *start_routine(void *ptr)
  {
      printf("子线程(%lu)等待3秒后退出...\n", pthread_self());
      sleep(3);
      student *pstu = (student *)ptr;
      printf("子线程(%lu)接收的数据: name = %s, age = %d, id = %d\n",
             pthread_self(), pstu->name, pstu->age, pstu->id);
      printf("子线程(%lu)即将退出...\n", pthread_self());
      return (void *)NULL;
  }
  
  int main(int argc, char const *argv[])
  {
      printf("主线程(%lu)开始运行...\n", pthread_self());
  
      student stu;
      bzero(&stu, sizeof(stu));
      strcpy(stu.name, "zhang san");
      stu.age = 18;
      stu.id = 2022;
  
      pthread_t thread_id;
      {
          printf("父线程(%lu)传递的数据: name = %s, age = %d, id = %d\n",
                 pthread_self(), stu.name, stu.age, stu.id);
          pthread_create(&thread_id, NULL, start_routine, &stu);
      }
  
      printf("主线程(%lu)等待5秒后结束...\n", pthread_self());
      sleep(5);
  
      printf("主线程(%lu)即将退出...\n", pthread_self());
      exit(EXIT_SUCCESS);
  }
  ```

- 输出

  > 主线程(139644495886144)开始运行...
  > 父线程(139644495886144)传递的数据: name = zhang san, age = 18, id = 2022
  > 主线程(139644495886144)等待5秒后结束...
  > 子线程(139644495881984)等待3秒后退出...
  > 子线程(139644495881984)接收的数据: name = zhang san, age = 18, id = 2022
  > 子线程(139644495881984)即将退出...
  > 主线程(139644495886144)即将退出...

### 2.2.4 线程属性之CPU时钟

```c
#include <pthread.h>
#include <time.h>

int pthread_getcpuclockid(pthread_t thread, clockid_t *clock_id);
```

### 2.2.5 线程属性之调度策略与调度参数

```c
int pthread_setschedparam(pthread_t thread, int policy, const struct sched_param *param);
int pthread_getschedparam(pthread_t thread, int *policy, struct sched_param *param);
```

### 2.2.6 线程属性之调度优先级

```c
int pthread_setschedprio(pthread_t thread, int prio);
```

### 2.2.7 案例：获取线程属性

- 源码

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <pthread.h>
  #include <string.h>
  #include <time.h>
  
  void *start_routine(void *ptr)
  {
      printf("子线程(%lu)等待3秒后退出...\n", pthread_self());
  
      clockid_t clock_id;
      pthread_getcpuclockid(pthread_self(), &clock_id);
      printf("子线程(%lu)的CPU时钟ID(%d)\n", pthread_self(), clock_id);
  
      int sched_policy;
      struct sched_param param;
      pthread_getschedparam(pthread_self(), &sched_policy, &param);
      printf("子线程(%lu)的调度策略(%s)\n", pthread_self(),
             sched_policy == SCHED_FIFO ? "SCHED_FIFO" :
             sched_policy == SCHED_RR  ? "SCHED_RR" :
             sched_policy == SCHED_OTHER ? "SCHED_OTHER" : "???");
      printf("子线程(%lu)的调度优先级(%d)\n", pthread_self(), param.sched_priority);
  
      printf("子线程(%lu)即将退出...\n", pthread_self());
      return (void *)NULL;
  }
  
  int main(int argc, char const *argv[])
  {
      printf("主线程(%lu)开始运行...\n", pthread_self());
  
      pthread_t thread_id;
      pthread_create(&thread_id, NULL, start_routine, NULL);
  
      clockid_t clock_id;
      pthread_getcpuclockid(pthread_self(), &clock_id);
      printf("主线程(%lu)的CPU时钟ID(%d)\n", pthread_self(), clock_id);
  
      int sched_policy;
      struct sched_param param;
      pthread_getschedparam(pthread_self(), &sched_policy, &param);
      printf("主线程(%lu)的调度策略(%s)\n", pthread_self(),
             sched_policy == SCHED_FIFO ? "SCHED_FIFO" :
             sched_policy == SCHED_RR  ? "SCHED_RR" :
             sched_policy == SCHED_OTHER ? "SCHED_OTHER" : "???");
      printf("主线程(%lu)的调度优先级(%d)\n", pthread_self(), param.sched_priority);
  
      printf("主线程(%lu)等待5秒后结束...\n", pthread_self());
      sleep(5);
  
      printf("主线程(%lu)即将退出...\n", pthread_self());
      exit(EXIT_SUCCESS);
  }
  ```

- 输出

  > 主线程(139759329433408)开始运行...
  > 主线程(139759329433408)的CPU时钟ID(-50154)
  > 子线程(139759329429248)等待3秒后退出...
  > 子线程(139759329429248)的CPU时钟ID(-50162)
  > 子线程(139759329429248)的调度策略(SCHED_OTHER)
  > 子线程(139759329429248)的调度优先级(0)
  > 子线程(139759329429248)即将退出...
  > 主线程(139759329433408)的调度策略(SCHED_OTHER)
  > 主线程(139759329433408)的调度优先级(0)
  > 主线程(139759329433408)等待5秒后结束...
  > 主线程(139759329433408)即将退出...

### 2.2.8 线程属性之非共享数据

程序经常需要在不同的线程中使用全局或静态变量，这些变量不同的线程中拥有不同的值。由于同一个进程中的所有线程共享相同的内存空间，因此常规的变量无法实现该需求。

为满足以上需求，提出了线程特有数据的概念。每个线程有一个私有的内存块，这个内存块就是线程的特有区域。该区域使用键值进行索引，使用`void *`类型。

当创建一个线程时，所有的线程特有数据的键值均为`NULL`。

```c
typedef unsigned int pthread_key_t;

int pthread_key_create(pthread_key_t *key, void (*destr_function) (void *));
int pthread_key_delete(pthread_key_t key);
int pthread_setspecific(pthread_key_t key, const void *pointer);
void * pthread_getspecific(pthread_key_t key);
```

- `pthread_key_create`

  - 用于创建一个新的键值。

  - 参数`destr_function`如果非`NULL`，指定与键值相关的析构函数。当线程通过`pthread_exit`或取消操作进行终结时，指定的析构函数被调用，其参数为键值对应的数据。如果赋值为`NULL`，则不进行调用。如果有多个键值对应的数据需要析构，则其调用的顺序是不确定的。

### 2.2.9 案例：私有数据的使用

- 源码

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <pthread.h>
  #include <string.h>
  
  pthread_key_t key;
  
  void *start_routine(void *ptr)
  {
      printf("子线程(%lu)开始运行...\n", pthread_self());
      pthread_key_t key = *((pthread_key_t *)ptr);
  
      // 主线程向KEY中写入值
      int specific_data = 88;
      pthread_setspecific(key, &specific_data);
  
      sleep(3);
  
      // 主线程从KEY中获取值
      int *p_specific_data = pthread_getspecific(key);
      printf("主线程(%lu)的私有数据(%d), 地址(%p)\n", pthread_self(), *p_specific_data, p_specific_data);
  
      printf("子线程(%lu)即将退出...\n", pthread_self());
      return (void *)NULL;
  }
  
  int main(int argc, char const *argv[])
  {
      printf("主线程(%lu)开始运行...\n", pthread_self());
  
      // 初始化KEY
      pthread_key_create(&key, NULL);
  
      // 主线程向KEY中写入值
      int specific_data = 99;
      pthread_setspecific(key, &specific_data);
  
      pthread_t thread_id;
      pthread_create(&thread_id, NULL, start_routine, &key);
  
      // 主线程从KEY中获取值
      int *p_specific_data = pthread_getspecific(key);
      printf("主线程(%lu)的私有数据(%d), 地址(%p)\n", pthread_self(), *p_specific_data, p_specific_data);
  
      sleep(5);
  
      // 销毁KEY
      pthread_key_delete(key);
  
      printf("主线程(%lu)即将退出...\n", pthread_self());
      exit(EXIT_SUCCESS);
  }
  ```

- 输出

  > 主线程(140110147004224)开始运行...
  > 主线程(140110147004224)的私有数据(99), 地址(0x7ffe404081f4)
  > 子线程(140110147000064)开始运行...
  > 主线程(140110147000064)的私有数据(88), 地址(0x7f6def8a8ec8)
  > 子线程(140110147000064)即将退出...
  > 主线程(140110147004224)即将退出...

### 2.2.10 判断线程ID是否相等

```c
int pthread_equal(pthread_t t1, pthread_t t2);
```

- 相等返回非零
- 不等但会零

### 2.2.11 单次初始化

```c
pthread_once_t once_control = PTHREAD_ONCE_INIT;
int pthread_once(pthread_once_t *once_control, void (*init_routine) (void));
```

- 用于保证参数`init_routine`中的代码最多执行一次

### 2.2.13 案例：单次初始化的使用

- 源码

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <pthread.h>
  #include <time.h>
  
  pthread_once_t once = PTHREAD_ONCE_INIT;
  
  void init_routine(void)
  {
      printf("线程(%lu)执行初始化\n", pthread_self());
  }
  
  
  void *start_routine(void *ptr)
  {
      printf("子线程(%lu)开始运行...\n", pthread_self());
      pthread_once(&once, init_routine);
      printf("子线程(%lu)即将退出...\n", pthread_self());
      return (void*)"9999";
  }
  
  int main(int argc, char const *argv[])
  {
      printf("主线程(%lu)开始运行...\n", pthread_self());
      
      pthread_t thread_id_01;
      pthread_create(&thread_id_01, NULL, start_routine, NULL);
  
      pthread_t thread_id_02;
      pthread_create(&thread_id_02, NULL, start_routine, NULL);
  
      printf("主线程(%lu)即将退出...\n", pthread_self());
      exit(EXIT_SUCCESS);
  }
  ```

- 输出

  > 主线程(140486961612608)开始运行...
  > 子线程(140486961608448)开始运行...
  > 线程(140486961608448)执行初始化
  > 子线程(140486961608448)即将退出...
  > 主线程(140486961612608)即将退出...

## 2.3 线程状态

### 2.3.1 链接态线程

```cpp
int pthread_join(pthread_t thread, void **retval);
int pthread_tryjoin_np(pthread_t thread, void **retval);
int pthread_timedjoin_np(pthread_t thread, void **retval, const struct timespec *abstime);
```

- `pthread_join`
  - 阻塞函数
  - 参数`retval`用于接收线程的返回值。如果不需要，设置为`NULL`
  - 调用该函数的线程将等待参数`thread`所标识的线程的退出
  - 参数`thread`所标识的线程的资源在调用`pthread_join`时释放

- `pthread_tryjoin_np`
  - 该函数执行非阻塞的链接。
  - 如果调用该函数时，参数`thread`指定的线程已终止，则其功能与`pthread_join`相同
  - 如果调用该函数时，参数`thread`指定的线程尚未终止，则该函数以错误的方式立即返回
- `pthread_timedjoin_np`
  - 带超时时间的链接。
  - 如果线程尚未终止，且线程在参数`abstime`指定的时间内结束，则其功能与`pthread_join`相同
  - 如果超时在线程终止前到期，则函数返回调用超时错误。

### 2.3.2 案例：链接态线程使用之pthread_join

- 源码

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <pthread.h>
  
  void *start_routine(void *ptr)
  {
      printf("子线程(%lu)开始运行...\n", pthread_self());
  
      sleep(3);
  
      printf("子线程(%lu)即将退出...\n", pthread_self());
      return (void*)"9999";
  }
  
  int main(int argc, char const *argv[])
  {
      printf("主线程(%lu)开始运行...\n", pthread_self());
  
      pthread_t thread_id;
      pthread_create(&thread_id, NULL, start_routine, NULL);
      
      void *retval = NULL;
      pthread_join(thread_id, &retval);
      printf("子线程的返回值为：%s\n", (const char*)retval);
  
      printf("主线程(%lu)即将退出...\n", pthread_self());
      exit(EXIT_SUCCESS);
  }
  ```

- 输出

  > 主线程(140647242364736)开始运行...
  > 子线程(140647242360576)开始运行...
  > 子线程(140647242360576)即将退出...
  > 子线程的返回值为：9999
  > 主线程(140647242364736)即将退出...

### 2.3.3 案例：链接态线程使用之pthread_tryjoin_np

- 源码

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <pthread.h>
  
  void *start_routine(void *ptr)
  {
      printf("子线程(%lu)开始运行...\n", pthread_self());
  
      sleep(3);
  
      printf("子线程(%lu)即将退出...\n", pthread_self());
      return (void*)"9999";
  }
  
  void TEST_Join(int timeout)
  {
      printf("\n");
  
      pthread_t thread_id;
      pthread_create(&thread_id, NULL, start_routine, NULL);
  
      sleep(timeout);
      void *retval = NULL;
      int ret = pthread_tryjoin_np(thread_id, &retval);
      printf("函数返回值     :%d\n", ret);
      printf("子线程的返回值为:%s\n", (const char*)retval);
  
      printf("\n");
  }
  
  int main(int argc, char const *argv[])
  {
      printf("主线程(%lu)开始运行...\n", pthread_self());
  
      TEST_Join(0);   // 调用函数时，子线程尚未结束
      sleep(5);
      TEST_Join(5);   // 调用函数是，子线程已终结
  
      printf("主线程(%lu)即将退出...\n", pthread_self());
      exit(EXIT_SUCCESS);
  }
  ```

- 输出

  > 主线程(140402546759488)开始运行...
  >
  > 子线程(140402546755328)开始运行...
  > 函数返回值     :16
  > 子线程的返回值为:(null)
  >
  > 子线程(140402546755328)即将退出...
  >
  > 子线程(140402538362624)开始运行...
  > 子线程(140402538362624)即将退出...
  > 函数返回值     :0
  > 子线程的返回值为:9999
  >
  > 主线程(140402546759488)即将退出...

### 2.3.4 案例：链接态线程使用之pthread_timedjoin_np

- 源码

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <pthread.h>
  #include <time.h>
  
  void *start_routine(void *ptr)
  {
      printf("子线程(%lu)开始运行...\n", pthread_self());
  
      sleep(3);
  
      printf("子线程(%lu)即将退出...\n", pthread_self());
      return (void*)"9999";
  }
  
  void TEST_Join(int timeout)
  {
      pthread_t thread_id;
      pthread_create(&thread_id, NULL, start_routine, NULL);
  
      struct timespec ts;
      ts.tv_sec = 5;
      ts.tv_nsec = 0;
  
      void *retval = NULL;
      time_t start, end; 
      time(&start);
      int ret = pthread_timedjoin_np(thread_id, &retval, &ts);
      time(&end);
      printf("函数耗时     :%lf\n", difftime(end, start));
      // ETIMEDOUT = 110;等待在线程结束前终止
      // EINVAL = 22
      printf("函数返回值     :%d\n", ret);  
      printf("子线程的返回值为:%s\n", (const char*)retval);
  }
  
  int main(int argc, char const *argv[])
  {
      printf("主线程(%lu)开始运行...\n", pthread_self());
      TEST_Join(1);   // 调用函数时，子线程尚未结束
      sleep(5);
      TEST_Join(5);   // 调用函数是，子线程已终结
  
      printf("主线程(%lu)即将退出...\n", pthread_self());
      exit(EXIT_SUCCESS);
  }
  ```

- 输出

  > 未测试出效果

### 2.3.2 分离态线程

```cpp
int pthread_detach(pthread_t thread);
```

- 分离态线程，在线程结束时自动释放资源
- 分离态线程，无法获得其返回值

### 2.3.3 案例：分离态线程使用

- 源码

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <pthread.h>
  
  void *start_routine(void *ptr)
  {
      printf("子线程(%lu)开始运行...\n", pthread_self());
  
      sleep(3);
  
      printf("子线程(%lu)即将退出...\n", pthread_self());
      return (void*)"9999";
  }
  
  int main(int argc, char const *argv[])
  {
      printf("主线程(%lu)开始运行...\n", pthread_self());
  
      pthread_t thread_id;
      pthread_create(&thread_id, NULL, start_routine, NULL);
      pthread_detach(thread_id);
  
      sleep(5);
  
      printf("主线程(%lu)即将退出...\n", pthread_self());
      exit(EXIT_SUCCESS);
  }
  ```

- 输出

  > 主线程(140334013024064)开始运行...
  > 子线程(140334013019904)开始运行...
  > 子线程(140334013019904)即将退出...
  > 主线程(140334013024064)即将退出...

## 2.4 线程退出

线程正常退出的几种方式：

- 在线程工作函数中调用`pthread_exit`，此时可使用`pthread_join`接收`pthread_exit`的参数值

- 线程工作函数运行结束

- 同一进程中的任意一个子线程调用`exit`，或者主线程结束
- 线程可以被从另一个线程中取消`pthread_cancel`

### 2.4.1 API

```c
void pthread_exit(void *retval);
```

- 如果为链接态线程，参数`retval`指示的返回值，可用`pthread_join`进行接收

### 2.4.3 案例：显式退出链接态线程

- 源码

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <pthread.h>
  
  void *start_routine(void *ptr)
  {
      printf("子线程(%lu)开始运行...\n", pthread_self());
  
      int num = 0;
      while (1)
      {
          printf("子线程(%lu)正在执行，%d...\n", pthread_self(), ++num);
          sleep(1);
          if (num > 3)
              pthread_exit((void **)"8888");
      }
  
      printf("子线程(%lu)即将退出...\n", pthread_self());
      return (void *)"9999";
  }
  
  int main(int argc, char const *argv[])
  {
      printf("主线程(%lu)开始运行...\n", pthread_self());
  
      pthread_t thread_id;
      pthread_create(&thread_id, NULL, start_routine, NULL);
  
      void *retval = NULL;
      pthread_join(thread_id, &retval);
      printf("子线程的返回值为：%s\n", (const char *)retval);
  
      printf("主线程(%lu)即将退出...\n", pthread_self());
      exit(EXIT_SUCCESS);
  }
  ```

- 输出

  > 主线程(140657300412224)开始运行...
  > 子线程(140657300408064)开始运行...
  > 子线程(140657300408064)正在执行，1...
  > 子线程(140657300408064)正在执行，2...
  > 子线程(140657300408064)正在执行，3...
  > 子线程(140657300408064)正在执行，4...
  > 子线程的返回值为：8888
  > 主线程(140657300412224)即将退出...

## 2.5 线程取消

### 2.5.1 API

```c
int pthread_cancel(pthread_t thread);
```

发送一个取消请求。目标线程是否响应与什么时候响应依赖于`可取消状态`与`可取消类型`属性。

### 2.5.2 可取消状态

```c
int pthread_setcancelstate(int state, int *oldstate);
```

可取消状态可通过函数`pthread_setcancelstate`函数进行设置。默认为启用。

- 如果线程禁用（`PTHREAD_CANCEL_DISABLE`）了可取消状态属性，则取消请求将保留到可取消状态被启用
- 如果线程启用（`PTHREAD_CANCEL_ENABLE`）了可取消状态属性，则可取消类型决定取消行为什么时候发生

### 2.5.3 可取消类型

```c
int pthread_setcanceltype(int type, int *oldtype);
```

可以取消类型可通过函数`pthread_setcanceltype`函数进行设置。可能值为`异步`与`延迟`。

- 异步（`PTHREAD_CANCEL_ASYNCHRONOUS`）

  异步的可取消类型意味着可以在任意时刻取消（通常是立即取消，但系统不保证）。

- 延迟（`PTHREAD_CANCEL_DEFERRED`）

  异步的可取消类型意味着取消被延迟直到下次调用取消点函数

  > 取消点函数列表可通过`man 7 pthreads`进行查询

### 2.5.3 取消过程

```c
void pthread_cleanup_push(void (*routine)(void *), void *arg);
void pthread_cleanup_pop(int execute);
```

当一个取消请求被实施，将按下述步骤进行实施：

- 取消清理函数入栈与调用（`pthread_cleanup_push`）
- 线程私有数据的析构函数以不确定顺序的方式被调用
- 终结线程

### 2.5.4 案例：取消线程执行

- 源码

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <pthread.h>
  
  void *start_routine_01(void *ptr)
  {
      printf("子线程(%lu)开始运行...\n", pthread_self());
  
      int num = 0;
      while (1)
      {
          printf("子线程(%lu)正在执行，%d...\n", pthread_self(), ++num);
          sleep(1);
      }
  
      printf("子线程(%lu)即将退出...\n", pthread_self());
      return (void *)"8888";
  }
  
  void *start_routine_02(void *ptr)
  {
      printf("子线程(%lu)开始运行...\n", pthread_self());
  
      sleep(3);
      pthread_cancel(*((pthread_t*)ptr));
      printf("子线程(%lu)取消信号已发出\n", pthread_self());
  
      printf("子线程(%lu)即将退出...\n", pthread_self());
      return (void *)"9999";
  }
  
  int main(int argc, char const *argv[])
  {
      printf("主线程(%lu)开始运行...\n", pthread_self());
  
      pthread_t thread_id_01;
      pthread_create(&thread_id_01, NULL, start_routine_01, NULL);
  
      pthread_t thread_id_02;
      pthread_create(&thread_id_02, NULL, start_routine_02, &thread_id_01);
  
      pthread_join(thread_id_01, NULL);
      pthread_join(thread_id_02, NULL);
  
      printf("主线程(%lu)即将退出...\n", pthread_self());
      exit(EXIT_SUCCESS);
  }
  ```

- 输出

  > 主线程(140162664855360)开始运行...
  > 子线程(140162664851200)开始运行...
  > 子线程(140162664851200)正在执行，1...
  > 子线程(140162656458496)开始运行...
  > 子线程(140162664851200)正在执行，2...
  > 子线程(140162664851200)正在执行，3...
  > 子线程(140162664851200)正在执行，4...
  > 子线程(140162656458496)取消信号已发出
  > 子线程(140162656458496)即将退出...
  > 主线程(140162664855360)即将退出...

# 3. 线程互斥与同步

## 3.1 问题引入

一个进程可以创建多个线程，这些线程的执行顺序是不确定的，但是相互独立。如果这些线程同时访问一个公共资源（例如，全局变量），这时可能会出现问题。

下面的例子中，开启了两个线程，每个线程中均对全局变量`g_num`执行自加一万此。理论上，最终的计算结果是`20000`，但实际运行结果与预想相差甚大。

```c++
#include <stdio.h>   // printf fprintf
#include <stdlib.h>  // EXIT_FAILURE EXIT_SUCCESS
#include <unistd.h>  // sleep
#include <pthread.h> // pthread_create pthread_t

int g_num = 0;

void *start_routine_01(void *ptr)
{
    for (size_t i = 0; i < 10000; i++)
        g_num++;

    return (void *)"8888";
}

void *start_routine_02(void *ptr)
{
    for (size_t i = 0; i < 10000; i++)
        g_num++;

    return (void *)"9999";
}

int main(int argc, char const *argv[])
{
    pthread_t thread_id_01;
    pthread_t thread_id_02;

    pthread_create(&thread_id_01, NULL, start_routine_01, NULL);
    pthread_create(&thread_id_01, NULL, start_routine_02, NULL);

    pthread_join(thread_id_01, NULL);
    pthread_join(thread_id_02, NULL);

    printf("计算结果为： %d\n", g_num);

    printf("主线程即将退出...\n");
    exit(EXIT_SUCCESS);
}
```

造成这种结果的原因为：`g_num++`操作并不是原子性的。数据操作的过程如下，先将数据的当前值从内存拷贝到寄存器，操作之后在从寄存器拷贝到内存中。多线程同时操作全局变量时，可能出现一下情况。例如，全局变量的当前值为1，线程一将数据从内存拷贝到寄存器0。由于线程调度还未执行自加操作，便开始执行其他任务。此时线程二亦开始操作该全局变量，并将该变量的值1拷贝到寄存器1，完成自加操作，并将结果2拷贝回内存。之后，线程一重新调度开始执行之前未完成的操作，将全局变量自加，并将结果拷贝回内存。**这时发生了数据覆盖，新的计算结果将之前的计算结果覆盖掉**。

## 3.2 互斥锁

### 3.2.1 互斥属性类型

```c
#define __SIZEOF_PTHREAD_MUTEXATTR_T 4
typedef union
{
    char __size[__SIZEOF_PTHREAD_MUTEXATTR_T];
    int __align;
} pthread_mutexattr_t;
```

### 3.2.2 初始化与销毁互斥属性

```c
int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);
int pthread_mutexattr_init(pthread_mutexattr_t *attr);
```

初始化与销毁互斥属性对象。

- `pthread_mutexattr_init`以默认值初始化互斥属性对象。使用一个未初始化的互斥属性对象，将导致不确定性的行为。如果输入`NULL`，将使用默认的互斥属性值。
- `pthread_mutexattr_destroy`销毁指定的互斥属性对象。一个已销毁的对象可以被重新初始化。使用一个已销毁的互斥属性对象，将导致不确定的行为。该函数在`LinuxThread`环境中的实现不做任何事情。
- 一个互斥属性对象被修改或销毁不影响使用该互斥属性对象创建的互斥量

### 3.2.3 互斥属性之锁类型

```c
int pthread_mutexattr_setkind_np(pthread_mutexattr_t *attr, int kind);
int pthread_mutexattr_getkind_np(const pthread_mutexattr_t *attr, int *kind);
```

- 已弃用。使用`pthread_mutexattr_settype & pthread_mutexattr_gettype`

```c
int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int kind);
int pthread_mutexattr_gettype(const pthread_mutexattr_t *attr, int *kind);
```

在`LinuxThread`仅支持一个互斥属性`mutex kind`。该值有以下可选值。

- `PTHREAD_MUTEX_FAST_NP`

  快速互斥。默认值

- `PTHREAD_MUTEX_RECURSIVE_NP`

  递归互斥

- `PTHREAD_MUTEX_ERRORCHECK_NP`带错误检查的互斥

- 后缀`NP`指示旋转是不可移植的（`non-portable`）

  `mutex kind`用于决定在企图加锁一个已经处于锁定状态的的互斥时将如何做。

  - 如果为`PTHREAD_MUTEX_FAST_NP`将挂起当前线程。
  - 如果为`PTHREAD_MUTEX_ERRORCHECK_NP`立即返回，并携带错误码`EDEADLK`。
  - 如果为`PTHREAD_MUTEX_RECURSIVE_NP`立即返回，并携带成功运行的返回码

### 3.2.4 初始化与销毁互斥

```c++
int pthread_mutex_destroy(pthread_mutex_t *mutex);
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
                       const pthread_mutexattr_t *restrict attr);
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
```

- `pthread_mutex_init`

  - 如果参数为`NULL`，使用默认属性进行初始化。正常初始化后，互斥的状态变成已初始化且未锁定状态。

  - 企图初始化一个已初始化的互斥对象，将导致不确定性行为。

  - 宏`PTHREAD_MUTEX_INITIALIZER`亦能完成互斥的初始化，但其不做错误检查。

- `pthread_mutex_destroy`

  - 互斥被销毁后变成一个非法值。一个已销毁的互斥对象可被重新初始化。引用一个已销毁的互斥将出现不可预期的行为。

  - 销毁一个未锁定且已初始化的互斥是安全的。企图销毁一个锁定状态或被引用（例如`pthread_cond_timedwait`或`pthread_cond_wait`）将导致不确定行为。

### 3.2.5 互斥之加锁解锁

```c
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```

- 如果互斥锁已被另一个线程锁定，调用线程将阻塞直到互斥锁可用。

- `pthread_mutex_lock`与`pthread_mutex_trylock`除加锁一个已经处于锁定状态的互斥时，前者进入阻塞状态，直接返回外，二者没区别。

### 3.2.6 案例：互斥锁的使用

使用互斥修改上一节中出错的样例，使其达到预期的效果。

> **使用流程**
>
> - 在每一个需要互斥的地方都需要先加锁，后解锁。
> - 加锁解锁必须成对使用，否则可能造成死锁
> - 最小代码块内进行加锁解锁，以提高程序运行效率

- 源码

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <pthread.h>
  
  pthread_mutex_t mutex;
  int g_num = 0;
  
  void *start_routine_01(void *ptr)
  {
      for (size_t i = 0; i < 10000; i++)
      {
          // 锁定最小单元
          pthread_mutex_lock(&mutex); // 锁定
          g_num++;
          pthread_mutex_unlock(&mutex); // 解锁
      }
      return (void *)NULL;
  }
  
  void *start_routine_02(void *ptr)
  {
      for (size_t i = 0; i < 10000; i++)
      {
          // 锁定最小单元
          pthread_mutex_lock(&mutex); // 锁定
          g_num++;
          pthread_mutex_unlock(&mutex); // 解锁
      }
      return (void *)NULL;
  }
  
  int main(int argc, char const *argv[])
  {
      pthread_mutexattr_t attr;      // 定义互斥属性
      pthread_mutexattr_init(&attr); // 初始化互斥属性
  
      pthread_mutex_init(&mutex, &attr); // 初始化互斥
      pthread_mutexattr_destroy(&attr);  // 销毁互斥属性
  
      pthread_t thread_id_01;
      pthread_t thread_id_02;
  
      pthread_create(&thread_id_01, NULL, start_routine_01, NULL);
      pthread_create(&thread_id_01, NULL, start_routine_02, NULL);
  
      pthread_join(thread_id_01, NULL);
      pthread_join(thread_id_02, NULL);
  
      printf("计算结果为： %d\n", g_num);
  
      printf("主线程即将退出...\n");
  
      pthread_mutex_destroy(&mutex); // 销毁互斥
      exit(EXIT_SUCCESS);
  }
  ```

- 结果

  > 计算结果为： 20000
  > 主线程即将退出...

## 3.3 条件变量

互斥量能够保证在微观层面同一时刻仅有一个线程处理变量，但是不能保证执行顺序，更不能在某一时刻，一个线程通知另一个线程开始开始处理相关任务。

### 3.3.1 条件变量属性类型

```c
#define __SIZEOF_PTHREAD_MUTEXATTR_T 4

typedef union
{
  char __size[__SIZEOF_PTHREAD_CONDATTR_T];
  int __align;
} pthread_condattr_t;
```

### 3.3.2 初始化与销毁条件变量属性

```c
int pthread_condattr_destroy(pthread_condattr_t *attr);
int pthread_condattr_init(pthread_condattr_t *attr);
```

- `pthread_condattr_init`
  - 以默认值初始化条件变量属性。
  - 完成初始化以后，可使用该条件变量属性创建一个或多个条件变量。
  - 修改或销毁条件变量不影响使用该属性创建的条件变量。
  - 初始化一个已初始化的条件变量属性对象，将导致不确定性行为
- `pthread_condattr_destroy`
  - 销毁指定条件变量属性对象
  - 执行完成后，条件变量属性对象编程未初始化状态
  - 已销毁的条件变量属性对象可以被再次初始化
  - 销毁一个已销毁的条件变量属性对象，将导致不确定性行为

### 3.3.3 初始化与销毁条件变量

```c
int pthread_cond_destroy(pthread_cond_t *cond);
int pthread_cond_init(pthread_cond_t *restrict cond,
                      const pthread_condattr_t *restrict attr);
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
```

初始化与销毁条件变量。

- `pthread_cond_init`
  - 初始化一个条件变量
  - 如果条件变量属性设置为`NULL`，则以默认的条件变量属性进行初始化
  - 执行成功之后，条件变量变为已初始化状态
- `pthread_cond_destroy`
  - 销毁指定的条件变量
  - 执行成功后，条件变量编程未初始化状态
  - 已销毁的条件变量可以被重新初始化
  - 销毁一个已销毁的条件变量，将导致不确定性行为
  - 销毁一个已初始化且未阻塞任何线程的条件变量是可行的
  - 企图销毁一个正在使用的条件变量将导致不确定性行为

### 3.3.4 条件变量之阻塞

```c
int pthread_cond_timedwait(pthread_cond_t *restrict cond,
                           pthread_mutex_t *restrict mutex,
                           const struct timespec *restrict abstime);
int pthread_cond_wait(pthread_cond_t *restrict cond,
                      pthread_mutex_t *restrict mutex);
```

- 调用这两个函数将导致线程处于阻塞到一个条件变量
- 当收到解锁信号后，阻塞将自动解除
- `pthread_cond_timedwait`该函数使线程处于阻塞状态到指定的时间，如果在指定的时间内，还未等到信号，则退出等待

### 3.3.5 条件变量之通知

```c
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_signal(pthread_cond_t *cond);
```

- `pthread_cond_signal`

  解除多个堵塞在同一个条件变量上的线程中的其中一个

- `pthread_cond_broadcast`

  解除所有阻塞在通过条件变量上的所有线程

### 3.3.6 案例：条件变量的使用

- 源码

  线程一启动后进入阻塞状态，等待信号的到来。线程二在启动后，等待5秒后发出信号。

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <pthread.h>
  
  pthread_mutex_t mutex;
  pthread_cond_t cond;
  
  void *start_routine_01(void *ptr)
  {
      printf("进入阻塞状态...\n");
      pthread_mutex_lock(&mutex);
      pthread_cond_wait(&cond, &mutex);
      printf("获得信号以解除阻塞状态...\n");
  
      pthread_mutex_unlock(&mutex);
      return (void *)NULL;
  }
  
  void *start_routine_02(void *ptr)
  {
      printf("等待5秒后发出解除信号...\n");
      sleep(5);
      pthread_mutex_lock(&mutex);
      pthread_cond_signal(&cond);
      printf("解除信号已发出...\n");
  
      pthread_mutex_unlock(&mutex);
      return (void *)NULL;
  }
  
  int main(int argc, char const *argv[])
  {
      {
          pthread_mutexattr_t attr;      // 定义互斥属性
          pthread_mutexattr_init(&attr); // 初始化互斥属性
  
          pthread_mutex_init(&mutex, &attr); // 初始化互斥
          pthread_mutexattr_destroy(&attr);  // 销毁互斥属性
      }
  
      {
          pthread_condattr_t attr;      // 定义条件变量属性
          pthread_condattr_init(&attr); // 初始化条件变量属性
  
          pthread_cond_init(&cond, &attr); // 初始化条件变量
          pthread_condattr_destroy(&attr); // 销毁条件变量属性
      }
  
      pthread_t thread_id_01;
      pthread_t thread_id_02;
  
      pthread_create(&thread_id_01, NULL, start_routine_01, NULL);
      pthread_create(&thread_id_01, NULL, start_routine_02, NULL);
  
      pthread_join(thread_id_01, NULL);
      pthread_join(thread_id_02, NULL);
  
      pthread_mutex_destroy(&mutex); // 销毁互斥
      pthread_cond_destroy(&cond);   // 销毁条件变量
  
      exit(EXIT_SUCCESS);
  }
  ```

- 输出

  > 进入阻塞状态...
  > 等待5秒后发出解除信号...
  > 解除信号已发出...
  > 获得信号以解除阻塞状态...

## 3.4 读写锁

多线程对同一个变量进行操作时，总是有读有写。一般情况下，读的频率大于写的频率。多线程同时对一个变量进行读操作是被允许的，而同时对一个变量进行写操作或某些线程对变量进行读操作，另一些线程对变量进行写操作是不被允许的。如果使用互斥量，那同时只能有一个线程对变量进行操作，则影响的程序执行的效率。为此，`pthread`库提供了读写锁。

### 3.4.1 读写锁属性类型

  ```c
  #define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
  typedef union
  {
      char __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];
      long int __align;
  } pthread_rwlockattr_t;
  ```

### 3.4.2 初始化读写锁属性对象

  ```c
  int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);
  ```

- 以默认值初始化一个读写锁属性对象
- 初始化一个已初始化的读写锁属性对象，将导致不确定性行为
- 使用一个已销毁的或未初始化的读写锁属性对象 ，将导致不确定性行为
- 在使用读写锁属性对象初始化一个或多个读写锁对象之后，修改或销毁该读写锁属性对象不影响已创建的读写锁对象

### 3.4.3 销毁读写锁属性对象

  ```c
  int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr);
  ```

- 销毁一个读写锁属性对象
- 一个已销毁的读写锁属性对象可以被重新初始化
- 释放一个未初始化的读写锁属性对象，将导致不确定性行为

### 3.4.4 读写锁属性之进程共享属性

```c
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict attr,
                                  int *restrict pshared);
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr, int pshared);
```

获取或设置读写锁属性对象中的`进程共享`属性。`进程共享`属性可以设置为以下值：

- `PTHREAD_PROCESS_SHARED`

  设置为该值，允许任何有权限访问的线程访问分配读写锁的内存，即使读写锁是在由多个进程共享的内存中分配的

- `PTHREAD_PROCESS_PRIVATE`

  读写锁只能由与初始化读写锁的线程在统一进程内创建的线程操作。如果不同进程的线程尝试操作该读写锁，则行为是未定义。该值为默认值。

> **注意**
>
> 设置或获取一个未初始化的读写锁属性对象，将导致不确定性行为。

### 3.4.5 读写锁属性之锁类型

```c
int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *attr, int pref);
int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *attr, int *pref);
```

获取或设置读写锁属性对象中的`锁类型`属性。`锁类型`属性有以下可选值：

- `PTHREAD_RWLOCK_PREFER_READER_NP`

  该属性是默认值。一个线程可以拥有多个读锁。根据`The Single Unix Specification`，当读取器尝试放置锁，但无写入锁的写入器正在等待时，此时的行为是未定义的。当锁类型被设置为`PTHREAD_RWLOCK_PREFER_READER_NP`时，则读写器优先。这意味着机器写入器正在等待，读取器将收到请求的锁。只要读取器一直存在，写入器将处于饥饿状态。

- `PTHREAD_RWLOCK_PREFER_WRITER_NP`

  This is intended as the write lock analog of `PTHREAD_RWLOCK_PREFER_READER_NP`.  This is ignored by `glibc` because the  `POSIX`  requirement  to  support  recursive  writer  locks  would  cause  this  option to create trivial deadlocks; instead use `PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP` which ensures the application developer will not take recursive read locks thus avoiding deadlocks.

- `PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP`

  Setting the lock kind to this avoids writer starvation as long as any read locking is not done in a recursive fashion.

### 3.4.6 初始化读写锁

```c
int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,
                        const pthread_rwlockattr_t *restrict attr);
pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;
```

### 3.4.7 销毁读写锁

```c
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
```

### 3.4.8 读写锁之加读锁

```c
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
```

### 3.4.9 读写锁之加写锁

```c
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
```

### 3.4.10 销毁读写锁

```c
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
```

### 3.4.11 案例：读写锁的使用

- 源码

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <pthread.h>
  
  int g_num = 0;
  pthread_rwlock_t rwlock;
  
  void *start_routine_01(void *ptr)
  {
      for (size_t i = 0; i < 5; i++)
      {
          pthread_rwlock_rdlock(&rwlock);
          for (size_t i = 0; i < 2; i++)
          {
              printf("读线程(%lu)获取全局变量当前值(%d)\n", pthread_self(), g_num);
              sleep(1);
          }
          pthread_rwlock_unlock(&rwlock);
          sleep(1);
      }
  
      return (void *)NULL;
  }
  
  void *start_routine_02(void *ptr)
  {
      for (size_t i = 0; i < 5; i++)
      {
          pthread_rwlock_rdlock(&rwlock);
          for (size_t i = 0; i < 2; i++)
          {
              printf("读线程(%lu)获取全局变量当前值(%d)\n", pthread_self(), g_num);
              sleep(1);
          }
          pthread_rwlock_unlock(&rwlock);
          sleep(1);
      }
  
      return (void *)NULL;
  }
  
  void *start_routine_03(void *ptr)
  {
      for (size_t i = 0; i < 5; i++)
      {
          pthread_rwlock_wrlock(&rwlock);
          printf("写线程(%lu)设置全局变量当前值(%d)\n", pthread_self(), ++g_num);
          pthread_rwlock_unlock(&rwlock);
          sleep(2);
      }
  
      return (void *)NULL;
  }
  
  int main(int argc, char const *argv[])
  {
      pthread_rwlockattr_t attr;
      pthread_rwlockattr_init(&attr);
      pthread_rwlock_init(&rwlock, &attr);
      pthread_rwlockattr_destroy(&attr);
  
      pthread_t thread_id_01, thread_id_02, thread_id_03;
      pthread_create(&thread_id_01, NULL, start_routine_01, NULL);
      pthread_create(&thread_id_02, NULL, start_routine_02, NULL);
      pthread_create(&thread_id_03, NULL, start_routine_03, NULL);
  
      pthread_join(thread_id_01, NULL);
      pthread_join(thread_id_02, NULL);
      pthread_join(thread_id_03, NULL);
  
      pthread_rwlock_destroy(&rwlock);
      exit(EXIT_SUCCESS);
  }
  ```

- 输出

  > 读线程(140456693409536)获取全局变量当前值(0)
  > 读线程(140456685016832)获取全局变量当前值(0)
  > 读线程(140456693409536)获取全局变量当前值(0)
  > 读线程(140456685016832)获取全局变量当前值(0)
  > 写线程(140456676624128)设置全局变量当前值(1)
  > 读线程(140456685016832)获取全局变量当前值(1)
  > 读线程(140456693409536)获取全局变量当前值(1)
  > 读线程(140456685016832)获取全局变量当前值(1)
  > 读线程(140456693409536)获取全局变量当前值(1)
  > 写线程(140456676624128)设置全局变量当前值(2)
  > 读线程(140456685016832)获取全局变量当前值(2)
  > 读线程(140456693409536)获取全局变量当前值(2)
  > 读线程(140456685016832)获取全局变量当前值(2)
  > 读线程(140456693409536)获取全局变量当前值(2)
  > 写线程(140456676624128)设置全局变量当前值(3)
  > 读线程(140456685016832)获取全局变量当前值(3)
  > 读线程(140456693409536)获取全局变量当前值(3)
  > 读线程(140456685016832)获取全局变量当前值(3)
  > 读线程(140456693409536)获取全局变量当前值(3)
  > 写线程(140456676624128)设置全局变量当前值(4)
  > 读线程(140456685016832)获取全局变量当前值(4)
  > 读线程(140456693409536)获取全局变量当前值(4)
  > 读线程(140456685016832)获取全局变量当前值(4)
  > 读线程(140456693409536)获取全局变量当前值(4)
  > 写线程(140456676624128)设置全局变量当前值(5)

  ## 3.5 信号量

信号量广泛用于进程或线程建的同步和互斥，信号量本质上是一个非负整数计数器，它被用来控制对公共资源的访问。编程时，可根据操作信号量值的结果判断是否对公共资源具有访问权限，当信号量值大于`0`时，则可以访问，否则将阻塞。`PV原语`是对信号量的操作，一次`P`操作是信号量`减1`，一次`V`操作使信号量`加1`。

  ### 3.5.1 信号量类型

```c
#if __WORDSIZE == 64
# define __SIZEOF_SEM_T	32
#else
# define __SIZEOF_SEM_T	16
#endif

typedef union
{
  char __size[__SIZEOF_SEM_T];
  long int __align;
} sem_t;
```

### 3.5.2 初始化信号量

```c
int sem_init(sem_t *sem, int pshared, unsigned int value);
```

- 初始化一个`无名信号量`
- 参数`pshared`指示该信号量是在`一个进程内的所有线程`共享还是在`进程间`共享
  - 如果该值为`0`，信号量被一个进程内的所有线程共享
  - 如果该值`非0`，信号量在进程间共享
- 参数`value`指示信号量额初始值
- 初始化一个已经初始化的信号量，将导致不确定性行为

### 3.5.3 销毁信号量

```c
int sem_destroy(sem_t *sem);
```

- 销毁一个`无名信号量`
- 仅通过`sem_init`初始化的信号量，使用该函数进行销毁
- 销毁一个正在被其他线程或进程使用的信号量，将导致不确定性行为
- 销毁一个已销毁的信号量，将导致不确定性行为
- 一个已销毁的信号量，可以被重新初始化

### 3.5.4 信号量P操作

```c
int sem_wait(sem_t *sem);
int sem_trywait(sem_t *sem);
int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
```

- `sem_wait`

  使信号量执行一次`P操作`。

  - 如果信号量的当前值大于零，则将信号量`减一`后，立即返回
  - 如果信号量的当前值等于零，则阻塞知道信号量变为可执行`P操作`或者一个信号处理中断被调用

- `sem_trywait`

  除了当前信号量不可执行`P操作`时，该函数直接返回，且将`errno`设置为`EAGAIN`外，与`sem_wait`相同

- `sem_timedwait`

  除了当前信号量不可执行`P操作`时，该函数将等待参数`abs_timeout`指定的时间外，与`sem_wait`相同。

  - 如果在等待时间内，能够执行`P操作`，则正常返回
  - 如果在等待时间内，不能执行`P操作`，则调用返回，且将`errno`设置为`ETIMEDOUT`

### 3.5.5 信号量V操作

```c
int sem_post(sem_t *sem);
```

- 将信号量的值`加1`

### 3.5.6 案例：信号量之线程互斥

> **注意**
>
> - 信号量用于互斥：不管多少个任务互斥，只需要一个信号量。
> - 对于每一个线程中的任务，都是先执行`P操作(sem_*wait)`，后执行`V操作(sem_post)`
> - 任务（线程）执行的先后顺序是不确定的

> **要求**
>
> - 任务（线程）一连续输出`0-4`
> - 任务（线程）二连续输出`10-14`
> - 任务（线程）三连续输出`20-24`
> - 任务（线程）的执行顺序无要求

- 源码

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <pthread.h>
  #include <semaphore.h>
  
  sem_t sem;
  void *start_routine_01(void *ptr)
  {
      sem_wait(&sem);
      for (size_t i = 0; i < 5; i++)
      {
          printf("读线程(%lu)获取全局变量当前值(%lu)\n", pthread_self(), i);
          sleep(1);
      }
      sem_post(&sem);
  
      return (void *)NULL;
  }
  
  void *start_routine_02(void *ptr)
  {
      sem_wait(&sem);
      for (size_t i = 10; i < 15; i++)
      {
          printf("读线程(%lu)获取全局变量当前值(%lu)\n", pthread_self(), i);
          sleep(1);
      }
      sem_post(&sem);
  
      return (void *)NULL;
  }
  
  void *start_routine_03(void *ptr)
  {
      sem_wait(&sem);
      for (size_t i = 20; i < 25; i++)
      {
          printf("读线程(%lu)获取全局变量当前值(%lu)\n", pthread_self(), i);
          sleep(1);
      }
      sem_post(&sem);
  
      return (void *)NULL;
  }
  
  int main(int argc, char const *argv[])
  {
      sem_init(&sem, 0, 1);
  
      pthread_t thread_id_01, thread_id_02, thread_id_03;
      pthread_create(&thread_id_01, NULL, start_routine_01, NULL);
      pthread_create(&thread_id_02, NULL, start_routine_02, NULL);
      pthread_create(&thread_id_03, NULL, start_routine_03, NULL);
  
      pthread_join(thread_id_01, NULL);
      pthread_join(thread_id_02, NULL);
      pthread_join(thread_id_03, NULL);
  
      sem_destroy(&sem);
      exit(EXIT_SUCCESS);
  }
  ```

- 输出

  > 读线程(139881171838720)获取全局变量当前值(0)
  > 读线程(139881171838720)获取全局变量当前值(1)
  > 读线程(139881171838720)获取全局变量当前值(2)
  > 读线程(139881171838720)获取全局变量当前值(3)
  > 读线程(139881171838720)获取全局变量当前值(4)
  > 读线程(139881163446016)获取全局变量当前值(10)
  > 读线程(139881163446016)获取全局变量当前值(11)
  > 读线程(139881163446016)获取全局变量当前值(12)
  > 读线程(139881163446016)获取全局变量当前值(13)
  > 读线程(139881163446016)获取全局变量当前值(14)
  > 读线程(139881155053312)获取全局变量当前值(20)
  > 读线程(139881155053312)获取全局变量当前值(21)
  > 读线程(139881155053312)获取全局变量当前值(22)
  > 读线程(139881155053312)获取全局变量当前值(23)
  > 读线程(139881155053312)获取全局变量当前值(24)

### 3.5.7 信号量之线程同步

> **注意**
>
> - 有多少个任务，就需要多少个信号量
> - 初始化时，最先执行的任务对应的信号量设置为`1`，其余信号量设置为`0`
> - 在每个任务（线程）中，先`P操作(sem_*wait)`自己，后`V操作(sem_post)`下一个任务

> **要求**
>
> - 任务（线程）一连续输出`0-4`
> - 任务（线程）二连续输出`10-14`
> - 任务（线程）三连续输出`20-24`
> - 任务（线程）的执行顺序必须是：
>   - 任务（线程）一
>   - 任务（线程）二
>   - 任务（线程）三

- 源码

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <pthread.h>
  #include <semaphore.h>
  
  sem_t sem_01, sem_02, sem_03;
  
  void *start_routine_01(void *ptr)
  {
      sem_wait(&sem_01);
      for (size_t i = 0; i < 5; i++)
      {
          printf("读线程(%lu)获取全局变量当前值(%lu)\n", pthread_self(), i);
          sleep(1);
      }
      sem_post(&sem_02);
  
      return (void *)NULL;
  }
  
  void *start_routine_02(void *ptr)
  {
      sem_wait(&sem_02);
      for (size_t i = 10; i < 15; i++)
      {
          printf("读线程(%lu)获取全局变量当前值(%lu)\n", pthread_self(), i);
          sleep(1);
      }
      sem_post(&sem_03);
  
      return (void *)NULL;
  }
  
  void *start_routine_03(void *ptr)
  {
      sem_wait(&sem_03);
      for (size_t i = 20; i < 25; i++)
      {
          printf("读线程(%lu)获取全局变量当前值(%lu)\n", pthread_self(), i);
          sleep(1);
      }
      sem_post(&sem_01);
  
      return (void *)NULL;
  }
  
  int main(int argc, char const *argv[])
  {
      sem_init(&sem_01, 0, 1);
      sem_init(&sem_02, 0, 0);
      sem_init(&sem_03, 0, 0);
  
      pthread_t thread_id_01, thread_id_02, thread_id_03;
      pthread_create(&thread_id_01, NULL, start_routine_01, NULL);
      pthread_create(&thread_id_02, NULL, start_routine_02, NULL);
      pthread_create(&thread_id_03, NULL, start_routine_03, NULL);
  
      pthread_join(thread_id_01, NULL);
      pthread_join(thread_id_02, NULL);
      pthread_join(thread_id_03, NULL);
  
      sem_destroy(&sem_01);
      sem_destroy(&sem_02);
      sem_destroy(&sem_03);
      exit(EXIT_SUCCESS);
  }
  ```

- 输出

  > 读线程(140602965497600)获取全局变量当前值(0)
  > 读线程(140602965497600)获取全局变量当前值(1)
  > 读线程(140602965497600)获取全局变量当前值(2)
  > 读线程(140602965497600)获取全局变量当前值(3)
  > 读线程(140602965497600)获取全局变量当前值(4)
  > 读线程(140602957104896)获取全局变量当前值(10)
  > 读线程(140602957104896)获取全局变量当前值(11)
  > 读线程(140602957104896)获取全局变量当前值(12)
  > 读线程(140602957104896)获取全局变量当前值(13)
  > 读线程(140602957104896)获取全局变量当前值(14)
  > 读线程(140602948712192)获取全局变量当前值(20)
  > 读线程(140602948712192)获取全局变量当前值(21)
  > 读线程(140602948712192)获取全局变量当前值(22)
  > 读线程(140602948712192)获取全局变量当前值(23)
  > 读线程(140602948712192)获取全局变量当前值(24)

## 3.5 栅栏

栅栏的功能与其字面含义大体相同，阻塞到达栅栏的线程，直到指定数目的线程全部到达。

### 3.5.1 栅栏属性类型

```c
#define __SIZEOF_PTHREAD_BARRIERATTR_T 4
typedef union
{
  char __size[__SIZEOF_PTHREAD_BARRIERATTR_T];
  int __align;
} pthread_barrierattr_t;
```

### 3.5.2 初始化与销毁栅栏属性

```c
int pthread_barrierattr_destroy(pthread_barrierattr_t *attr);
int pthread_barrierattr_init(pthread_barrierattr_t *attr);
```

### 3.5.3 栅栏属性之进程共享属性

```c
int pthread_barrierattr_getpshared(const pthread_barrierattr_t
                                   *restrict attr, int *restrict pshared);
int pthread_barrierattr_setpshared(pthread_barrierattr_t *attr,int pshared);
```

- `PTHREAD_PROCESS_SHARED`

  能够访问栅栏内存的所有线程

- `PTHREAD_PROCESS_PRIVATE`

  创建栅栏所在的进程内的所有线程

### 3.5.4 栅栏结构

```c
# define __SIZEOF_PTHREAD_BARRIER_T 20
typedef union
{
  char __size[__SIZEOF_PTHREAD_BARRIER_T];
  long int __align;
} pthread_barrier_t;
```

### 3.5.5 初始化与销毁栅栏

```c
int pthread_barrier_destroy(pthread_barrier_t *barrier);
int pthread_barrier_init(pthread_barrier_t *restrict barrier,
                         const pthread_barrierattr_t *restrict attr,
                         unsigned count);
```

### 3.5.6 栅栏等待

```c
int pthread_barrier_wait(pthread_barrier_t *barrier);
```

### 3.5.7 案例：栅栏的使用

- 源码

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <pthread.h>
  #include <time.h>
  
  pthread_barrier_t barrier;
  
  void *start_routine_01(void *ptr)
  {
      printf("子线程(%lu)开始运行...\n", pthread_self());
      printf("子线程(%lu)栅栏等待状态前\n", pthread_self());
      pthread_barrier_wait(&barrier);
      printf("子线程(%lu)栅栏等待状态后\n", pthread_self());
      printf("子线程(%lu)即将退出...\n", pthread_self());
      return (void*)"9999";
  }
  
  void *start_routine_02(void *ptr)
  {
      printf("子线程(%lu)开始运行...\n", pthread_self());
      printf("子线程(%lu)栅栏等待状态前\n", pthread_self());
      pthread_barrier_wait(&barrier);
      printf("子线程(%lu)栅栏等待状态后\n", pthread_self());
      printf("子线程(%lu)即将退出...\n", pthread_self());
      return (void*)"9999";
  }
  
  void *start_routine_03(void *ptr)
  {
      printf("子线程(%lu)开始运行...\n", pthread_self());
      printf("子线程(%lu)栅栏等待状态前\n", pthread_self());
      pthread_barrier_wait(&barrier);
      printf("子线程(%lu)栅栏等待状态后\n", pthread_self());
      printf("子线程(%lu)即将退出...\n", pthread_self());
      return (void*)"9999";
  }
  
  int main(int argc, char const *argv[])
  {
      printf("主线程(%lu)开始运行...\n", pthread_self());
  
      pthread_barrierattr_t attr;
      pthread_barrierattr_init(&attr);
      pthread_barrier_init(&barrier, &attr, 3);
      pthread_barrier_destroy(&attr);
      
      pthread_t thread_id_01;
      pthread_create(&thread_id_01, NULL, start_routine_01, NULL);
  
      pthread_t thread_id_02;
      pthread_create(&thread_id_02, NULL, start_routine_02, NULL);
  
      pthread_t thread_id_03;
      pthread_create(&thread_id_03, NULL, start_routine_03, NULL);
  
      pthread_join(thread_id_01, NULL);
      pthread_join(thread_id_02, NULL);
      pthread_join(thread_id_03, NULL);
  
      pthread_barrier_destroy(&barrier);
      printf("主线程(%lu)即将退出...\n", pthread_self());
      exit(EXIT_SUCCESS);
  }
  ```

- 输出

  > 主线程(140073106831168)开始运行...
  > 子线程(140073106827008)开始运行...
  > 子线程(140073106827008)栅栏等待状态前
  > 子线程(140073098434304)开始运行...
  > 子线程(140073098434304)栅栏等待状态前
  > 子线程(140073090041600)开始运行...
  > 子线程(140073090041600)栅栏等待状态前
  > 子线程(140073090041600)栅栏等待状态后
  > 子线程(140073090041600)即将退出...
  > 子线程(140073098434304)栅栏等待状态后
  > 子线程(140073098434304)即将退出...
  > 子线程(140073106827008)栅栏等待状态后
  > 子线程(140073106827008)即将退出...
  > 主线程(140073106831168)即将退出...

## 3.6 自旋锁

### 3.6.1 自旋锁类型

```c
typedef volatile int pthread_spinlock_t;
```

### 3.6.2 初始化与销毁自旋锁

```c
int pthread_spin_init(pthread_spinlock_t *lock, int pshared);
int pthread_spin_destroy(pthread_spinlock_t *lock);
```

- `PTHREAD_PROCESS_PRIVATE`
- `PTHREAD_PROCESS_SHARED`

### 3.6.3 自旋锁的加锁解锁

```c
int pthread_spin_lock(pthread_spinlock_t *lock);
int pthread_spin_trylock(pthread_spinlock_t *lock);
int pthread_spin_unlock(pthread_spinlock_t *lock);
```

### 3.6.3 案例：自旋锁的使用

- 源码

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <pthread.h>
  #include <time.h>
  
  pthread_spinlock_t spinlock;
  
  void *start_routine_01(void *ptr)
  {
      printf("子线程(%lu)开始运行...\n", pthread_self());
      for (size_t i = 0; i < 3; i++)
      {
          pthread_spin_lock(&spinlock);
          printf("子线程(%lu)进入自旋锁\n", pthread_self());
          sleep(1);
          printf("子线程(%lu)离开自旋锁\n", pthread_self());
          pthread_spin_unlock(&spinlock);
      }
      return (void*)"9999";
  }
  
  void *start_routine_02(void *ptr)
  {
      printf("子线程(%lu)开始运行...\n", pthread_self());
      for (size_t i = 0; i < 3; i++)
      {
          pthread_spin_lock(&spinlock);
          printf("子线程(%lu)进入自旋锁\n", pthread_self());
          sleep(1);
          printf("子线程(%lu)离开自旋锁\n", pthread_self());
          pthread_spin_unlock(&spinlock);
      }
      return (void*)"9999";
  }
  
  int main(int argc, char const *argv[])
  {
      printf("主线程(%lu)开始运行...\n", pthread_self());
  
      pthread_spin_init(&spinlock, PTHREAD_PROCESS_PRIVATE);
      
      pthread_t thread_id_01;
      pthread_create(&thread_id_01, NULL, start_routine_01, NULL);
  
      pthread_t thread_id_02;
      pthread_create(&thread_id_02, NULL, start_routine_02, NULL);
  
      pthread_join(thread_id_01, NULL);
      pthread_join(thread_id_02, NULL);
  
      pthread_spin_destroy(&spinlock);
      printf("主线程(%lu)即将退出...\n", pthread_self());
      exit(EXIT_SUCCESS);
  }
  ```

- 输出

  > 主线程(139684168165184)开始运行...
  > 子线程(139684168161024)开始运行...
  > 子线程(139684168161024)进入自旋锁
  > 子线程(139684159768320)开始运行...
  > 子线程(139684168161024)离开自旋锁
  > 子线程(139684168161024)进入自旋锁
  > 子线程(139684168161024)离开自旋锁
  > 子线程(139684168161024)进入自旋锁
  > 子线程(139684168161024)离开自旋锁
  > 子线程(139684159768320)进入自旋锁
  > 子线程(139684159768320)离开自旋锁
  > 子线程(139684159768320)进入自旋锁
  > 子线程(139684159768320)离开自旋锁
  > 子线程(139684159768320)进入自旋锁
  > 子线程(139684159768320)离开自旋锁
  > 主线程(139684168165184)即将退出...
